name: Markdown Web Scraper

on:
  workflow_dispatch:
    inputs:
      target_url:
        description: 'スクレイピング対象のURL'
        required: true
        default: 'https://example.com'
      max_depth:
        description: '最大深度 (1-5の範囲推奨)'
        required: true
        default: '2'
      use_proxy:
        description: 'CORSプロキシを使用 (true/false)'
        required: false
        default: 'false'
      proxy_url:
        description: 'プロキシURL (例: https://corsproxy.io/?)'
        required: false
        default: 'https://corsproxy.io/?'

jobs:
  scrape:
    runs-on: ubuntu-latest
    # GitHub Pagesへデプロイするための明示的な権限設定
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm init -y
          npm install puppeteer

      - name: Create markdown scraper script
        run: |
          cat > web-scraper-markdown.js << 'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');
          const path = require('path');
          const url = require('url');

          /**
           * ウェブページをスクレイピングしてマークダウン形式で保存する
           * @param {string} targetUrl スクレイピング対象のURL
           * @param {number} maxDepth 最大探索深度
           */
          async function scrapeToMarkdown(targetUrl, maxDepth = 2) {
            console.log(`スクレイピングを開始: ${targetUrl} (最大深度: ${maxDepth})`);
            
            // 出力ディレクトリの設定
            const outputDir = 'scraped_data';
            const mdOutputDir = path.join(outputDir, 'markdown');
            const imagesDir = path.join(mdOutputDir, 'images');
            
            // ディレクトリを作成
            fs.mkdirSync(outputDir, { recursive: true });
            fs.mkdirSync(mdOutputDir, { recursive: true });
            fs.mkdirSync(imagesDir, { recursive: true });
            
            // メタデータ初期化
            const metadata = {
              startUrl: targetUrl,
              startTime: new Date().toISOString(),
              maxDepth: maxDepth,
              pagesScraped: 0,
              markdownFiles: 0
            };
            
            // 訪問済みURLの記録
            const visitedUrls = new Set();
            // 処理待ちURLのキュー (URL, 深度)
            const urlQueue = [[targetUrl, 0]];
            
            // ブラウザを起動
            const browser = await puppeteer.launch({
              headless: true,
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            
            try {
              while (urlQueue.length > 0) {
                // URLキューから次の処理対象を取得
                const [currentUrl, depth] = urlQueue.shift();
                
                // 既に訪問済みの場合はスキップ
                if (visitedUrls.has(currentUrl)) {
                  continue;
                }
                
                // 最大深度を超えている場合はスキップ
                if (depth > maxDepth) {
                  continue;
                }
                
                console.log(`処理中 [深度: ${depth}]: ${currentUrl}`);
                
                // URLを訪問済みに追加
                visitedUrls.add(currentUrl);
                metadata.pagesScraped++;
                
                // ページを開く
                const page = await browser.newPage();
                await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36');
                
                try {
                  // ページに移動
                  await page.goto(currentUrl, {
                    waitUntil: 'networkidle2',
                    timeout: 60000
                  });
                  
                  // ページのメタデータを抽出
                  const pageMetadata = await page.evaluate(() => {
                    return {
                      title: document.title,
                      description: document.querySelector('meta[name="description"]')?.content || '',
                      canonical: document.querySelector('link[rel="canonical"]')?.href || window.location.href,
                    };
                  });
                  
                  // ページコンテンツをマークダウンに変換
                  const markdown = await extractContentAsMarkdown(page, imagesDir, currentUrl);
                  
                  // マークダウンファイル名の作成
                  const parsedUrl = new URL(currentUrl);
                  let fileName = parsedUrl.pathname.replace(/\//g, '_').replace(/^_/, '');
                  if (!fileName) fileName = 'index';
                  if (!fileName.endsWith('.md')) fileName += '.md';
                  
                  // マークダウンにメタデータを追加
                  const frontMatter = `---
          title: "${pageMetadata.title}"
          url: "${currentUrl}"
          description: "${pageMetadata.description}"
          date: "${new Date().toISOString()}"
          depth: ${depth}
          ---

          `;
                  
                  // マークダウンファイルを保存
                  const mdFilePath = path.join(mdOutputDir, fileName);
                  fs.writeFileSync(mdFilePath, frontMatter + markdown);
                  metadata.markdownFiles++;
                  
                  console.log(`マークダウンファイル保存: ${mdFilePath}`);
                  
                  // ページのスクリーンショットを保存
                  const screenshotName = fileName.replace('.md', '.png');
                  await page.screenshot({
                    path: path.join(outputDir, screenshotName),
                    fullPage: true
                  });
                  
                  // リンクを抽出して処理キューに追加（同一ドメインのみ）
                  if (depth < maxDepth) {
                    const links = await page.evaluate((baseUrl) => {
                      const sameDomain = (urlStr) => {
                        try {
                          // 相対URLの場合はbaseUrlのドメインを使用
                          if (urlStr.startsWith('/')) {
                            return true;
                          }
                          // 絶対URLの場合はドメインを比較
                          const base = new URL(baseUrl);
                          const url = new URL(urlStr, baseUrl);
                          return url.hostname === base.hostname;
                        } catch (e) {
                          return false;
                        }
                      };
                      
                      return Array.from(document.querySelectorAll('a[href]'))
                        .map(a => a.href)
                        .filter(href => href && !href.startsWith('#') && !href.startsWith('javascript:') && !href.startsWith('mailto:'))
                        .filter(href => sameDomain(href));
                    }, currentUrl);
                    
                    // 重複を除去して新しいリンクをキューに追加
                    const uniqueLinks = [...new Set(links)];
                    for (const link of uniqueLinks) {
                      if (!visitedUrls.has(link)) {
                        urlQueue.push([link, depth + 1]);
                      }
                    }
                  }
                } catch (err) {
                  console.error(`ページ処理エラー: ${currentUrl}`, err);
                } finally {
                  await page.close();
                }
              }
              
              // インデックスマークダウンを作成
              await createIndexMarkdown(mdOutputDir, visitedUrls, metadata);
              
              // メタデータ更新
              metadata.endTime = new Date().toISOString();
              metadata.duration = (new Date(metadata.endTime) - new Date(metadata.startTime)) / 1000;
              
              // メタデータをファイルに保存
              fs.writeFileSync(
                path.join(outputDir, 'metadata.json'),
                JSON.stringify(metadata, null, 2)
              );
              
              console.log('\nスクレイピング完了:');
              console.log(`- 処理ページ数: ${metadata.pagesScraped}`);
              console.log(`- マークダウンファイル数: ${metadata.markdownFiles}`);
              console.log(`- 処理時間: ${metadata.duration.toFixed(1)}秒`);
              
            } catch (error) {
              console.error('スクレイピング全体エラー:', error);
            } finally {
              await browser.close();
            }
          }

          /**
           * ページコンテンツをマークダウン形式で抽出する
           * @param {Page} page Puppeteerのページオブジェクト
           * @param {string} imagesDir 画像保存ディレクトリ
           * @param {string} baseUrl ベースURL
           * @returns {Promise<string>} マークダウン形式のコンテンツ
           */
          async function extractContentAsMarkdown(page, imagesDir, baseUrl) {
            // ページからマークダウンを抽出
            return await page.evaluate((baseUrl) => {
              /**
               * テキストを削除し、空白を整理する関数
               */
              function cleanText(text) {
                if (!text) return '';
                // 改行と余分な空白を整理
                return text.trim()
                  .replace(/\s+/g, ' ')
                  .replace(/\n+/g, '\n');
              }
              
              /**
               * 要素をマークダウンに変換する関数
               */
              function elementToMarkdown(element, depth = 0) {
                if (!element) return '';
                
                // 非表示要素はスキップ
                const style = window.getComputedStyle(element);
                if (style.display === 'none' || style.visibility === 'hidden') {
                  return '';
                }
                
                // 要素の種類によって処理を分ける
                const tagName = element.tagName.toLowerCase();
                
                // スキップする要素
                const skipTags = ['script', 'style', 'noscript', 'svg', 'nav', 'footer', 'iframe'];
                if (skipTags.includes(tagName)) {
                  return '';
                }
                
                // マークダウンに変換
                let md = '';
                
                switch (tagName) {
                  case 'h1':
                    return `# ${cleanText(element.textContent)}\n\n`;
                  case 'h2':
                    return `## ${cleanText(element.textContent)}\n\n`;
                  case 'h3':
                    return `### ${cleanText(element.textContent)}\n\n`;
                  case 'h4':
                    return `#### ${cleanText(element.textContent)}\n\n`;
                  case 'h5':
                    return `##### ${cleanText(element.textContent)}\n\n`;
                  case 'h6':
                    return `###### ${cleanText(element.textContent)}\n\n`;
                  case 'p':
                    const text = cleanText(element.textContent);
                    return text ? `${text}\n\n` : '';
                  case 'ul':
                    let ulItems = '';
                    Array.from(element.children).forEach(child => {
                      if (child.tagName.toLowerCase() === 'li') {
                        ulItems += `* ${cleanText(child.textContent)}\n`;
                      }
                    });
                    return ulItems ? `${ulItems}\n` : '';
                  case 'ol':
                    let olItems = '';
                    Array.from(element.children).forEach((child, i) => {
                      if (child.tagName.toLowerCase() === 'li') {
                        olItems += `${i + 1}. ${cleanText(child.textContent)}\n`;
                      }
                    });
                    return olItems ? `${olItems}\n` : '';
                  case 'a':
                    const href = element.getAttribute('href');
                    if (href && !href.startsWith('#') && !href.startsWith('javascript:')) {
                      // 相対URLを絶対URLに変換
                      const absoluteUrl = new URL(href, baseUrl).href;
                      return `[${cleanText(element.textContent)}](${absoluteUrl})`;
                    }
                    return cleanText(element.textContent);
                  case 'img':
                    const src = element.getAttribute('src');
                    const alt = element.getAttribute('alt') || '';
                    if (src) {
                      // 相対URLを絶対URLに変換
                      const absoluteSrc = new URL(src, baseUrl).href;
                      return `![${alt}](${absoluteSrc})`;
                    }
                    return '';
                  case 'code':
                  case
